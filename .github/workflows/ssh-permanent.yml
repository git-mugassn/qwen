name: Permanent SSH Node

on:
  workflow_dispatch:              # 支持手动触发
  repository_dispatch:            # 支持通过 API 触发
    types: [restart-permanent-node]

permissions:
  contents: write
  actions: write  # 允许触发其他 workflow

# 并发控制：新运行会取消旧运行，实现无缝切换
concurrency:
  group: permanent-ssh-node
  cancel-in-progress: true

jobs:
  debug:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Install OpenSSH
        run: |
          set -e
          echo ">>> Install OpenSSH, curl, openssl, python3"
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y openssh-server curl openssl python3
          elif command -v yum >/dev/null 2>&1; then
            sudo yum install -y openssh-server curl openssl python3
          else
            echo "Unsupported package manager, please install openssh-server & curl & openssl & python3 manually."
            exit 1
          fi

          echo ">>> OpenSSH installed"

      - name: Configure SSH, start bore tunnels and save endpoints
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_TTL_MINUTES: "330"
          NODE_WEB_PORTS: "8000"
        run: |
          set -euo pipefail

          TTL_MIN=${NODE_TTL_MINUTES:-60}
          TTL_SEC=$(( TTL_MIN * 60 ))
          PORT_LIST_STR="${NODE_WEB_PORTS:-}"

          echo ">>> TTL (minutes): $TTL_MIN"
          echo ">>> Extra TCP ports to expose via bore: ${PORT_LIST_STR:-<none>}"

          # ===== 创建本地 data 目录 =====
          echo ">>> Creating local /data directory (no WebDAV mount)"
          sudo mkdir -p /data
          sudo chown root:root /data
          echo ">>> Created local /data directory (data will not persist)"

          # 创建或更新 reboot.txt（只在文件不存在时创建模板）
          REBOOT_FILE="reboot.txt"
          if [ ! -f "$REBOOT_FILE" ]; then
            echo ">>> Creating reboot.txt template (first run or file doesn't exist)..."
            echo "# 开机时可以在这里添加自定义启动命令" > "$REBOOT_FILE"
            echo "# 例如：从备份恢复数据等" >> "$REBOOT_FILE"
            echo "" >> "$REBOOT_FILE"
            echo ">>> reboot.txt template created"
          else
            echo ">>> reboot.txt already exists, keeping existing content"
          fi
          
          # 创建或更新 shut.txt（只在文件不存在时创建模板）
          SHUTDOWN_FILE="shut.txt"
          if [ ! -f "$SHUTDOWN_FILE" ]; then
            echo ">>> Creating shut.txt template (first run or file doesn't exist)..."
            echo "# 关机前可以在这里添加自定义关机命令" > "$SHUTDOWN_FILE"
            echo "# 例如：清理临时文件、保存配置等" >> "$SHUTDOWN_FILE"
            echo "" >> "$SHUTDOWN_FILE"
            echo ">>> shut.txt template created"
          else
            echo ">>> shut.txt already exists, keeping existing content"
          fi

          # 自动下载并恢复最新备份（如果backup.txt存在）
          if [ -f "backup.txt" ] && [ -s "backup.txt" ]; then
            echo ">>> Found backup.txt, downloading latest backup..."
            
            # 获取最后一行备份信息
            LAST_LINE=$(tail -n 1 "backup.txt")
            LAST_FILENAME=$(echo "$LAST_LINE" | awk '{print $1}')
            
            # 检查是否是分片备份（文件名包含.part数字.tar.gz）
            if [[ "$LAST_FILENAME" =~ \.part[0-9]+\.tar\.gz$ ]]; then
              # 这是分片备份，提取基础文件名和时间戳
              BASE_NAME=$(echo "$LAST_FILENAME" | sed 's/\.part[0-9]*\.tar\.gz$//')
              echo ">>> Found split backup: $BASE_NAME"
              
              # 从backup.txt中找到所有相同基础名的分片
              # 在临时目录操作，避免权限问题
              cd /tmp
              DOWNLOAD_SUCCESS=true
              
              # 创建临时文件存储分片信息
              TEMP_PARTS="/tmp/backup_parts.txt"
              > "$TEMP_PARTS"
              
              # 倒序读取backup.txt，找到所有相同基础名的分片
              tac "$GITHUB_WORKSPACE/backup.txt" | while read -r line; do
                if [ -z "$line" ] || [[ "$line" =~ ^# ]]; then
                  continue
                fi
                
                FILENAME=$(echo "$line" | awk '{print $1}')
                FILE_URL=$(echo "$line" | awk '{print $2}')
                
                # 检查是否属于同一个备份的分片
                if [[ "$FILENAME" =~ ^${BASE_NAME}\.part[0-9]+\.tar\.gz$ ]]; then
                  echo "$FILENAME $FILE_URL" >> "$TEMP_PARTS"
                else
                  # 遇到不同备份的文件，停止
                  break
                fi
              done
              
              # 读取分片信息并下载
              PART_COUNT=0
              if [ -s "$TEMP_PARTS" ]; then
                while read -r FILENAME FILE_URL; do
                  PART_NUM=$(echo "$FILENAME" | grep -o 'part[0-9]*' | sed 's/part//')
                  echo ">>> Downloading part $PART_NUM: $FILENAME"
                  
                  if curl -L -o "$FILENAME" "$FILE_URL"; then
                    echo ">>> Part $PART_NUM downloaded successfully"
                    PART_COUNT=$((PART_COUNT + 1))
                  else
                    echo "!!! Failed to download part $PART_NUM"
                    DOWNLOAD_SUCCESS=false
                    break
                  fi
                done < "$TEMP_PARTS"
              fi
              
              rm -f "$TEMP_PARTS"
              
              if [ "$DOWNLOAD_SUCCESS" = true ] && [ "$PART_COUNT" -gt 0 ]; then
                echo ">>> All $PART_COUNT parts downloaded, reassembling..."
                BACKUP_FILE="${BASE_NAME}.tar.gz"
                
                # 重新组装文件（按part1, part2, part3...顺序）
                > "$BACKUP_FILE"  # 创建空文件
                for i in $(seq 1 "$PART_COUNT"); do
                  PART_FILE="${BASE_NAME}.part${i}.tar.gz"
                  if [ -f "$PART_FILE" ]; then
                    cat "$PART_FILE" >> "$BACKUP_FILE"
                    rm -f "$PART_FILE"
                  else
                    echo "!!! Part file $PART_FILE not found"
                    DOWNLOAD_SUCCESS=false
                    break
                  fi
                done
                
                if [ "$DOWNLOAD_SUCCESS" = true ]; then
                  # 先确保 /data 目录有正确权限
                  sudo chmod 755 /data
                  # 解压备份文件到 /data
                  if sudo tar -xzf "$BACKUP_FILE" -C /data; then
                    echo ">>> Split backup restored successfully to /data"
                    sudo chown -R root:root /data || true
                  else
                    echo "!!! Failed to extract reassembled backup file"
                  fi
                  
                  rm -f "$BACKUP_FILE"
                else
                  echo "!!! Failed to reassemble split backup"
                fi
              else
                echo "!!! Failed to download all parts of split backup"
              fi
              
              # 切换回仓库目录
              cd "$GITHUB_WORKSPACE"
              
            else
              # 这是单文件备份
              BACKUP_FILENAME=$(echo "$LAST_LINE" | awk '{print $1}')
              BACKUP_URL=$(echo "$LAST_LINE" | awk '{print $2}')
              
              if [ -n "$BACKUP_URL" ] && [ -n "$BACKUP_FILENAME" ]; then
                echo ">>> Downloading single backup: $BACKUP_FILENAME from $BACKUP_URL"
                # 在临时目录下载，避免权限问题
                cd /tmp
                
                # 下载备份文件
                if curl -L -o "$BACKUP_FILENAME" "$BACKUP_URL"; then
                  echo ">>> Download successful, extracting to /data..."
                  
                  # 先确保 /data 目录有正确权限
                  sudo chmod 755 /data
                  # 解压备份文件到 /data
                  if sudo tar -xzf "$BACKUP_FILENAME" -C /data; then
                    echo ">>> Backup restored successfully to /data"
                    # 设置正确的权限
                    sudo chown -R root:root /data || true
                  else
                    echo "!!! Failed to extract backup file"
                  fi
                  
                  # 清理下载的备份文件
                  rm -f "$BACKUP_FILENAME"
                else
                  echo "!!! Failed to download backup from $BACKUP_URL"
                fi
              else
                echo "!!! Invalid backup entry format in backup.txt"
              fi
              
              # 切换回仓库目录
              cd "$GITHUB_WORKSPACE"
            fi
          else
            echo ">>> No backup.txt found or file is empty, skipping backup restore (first run?)"
          fi

          # 执行重启命令文件（如果存在）
          REBOOT_FILE="reboot.txt"
          
          if [ -f "$REBOOT_FILE" ]; then
            echo ">>> Found $REBOOT_FILE, executing as script..."
            echo ">>> Working directory: /root"
            
            # 转换 Windows 换行符为 Unix 格式
            sed -i 's/\r$//' "$REBOOT_FILE" 2>/dev/null || true
            
            # 复制到 /root 并添加执行权限
            sudo cp "$REBOOT_FILE" /root/reboot.sh
            sudo chmod +x /root/reboot.sh
            
            # 直接执行脚本（不使用 eval）
            echo ">>> Executing /root/reboot.sh"
            sudo bash /root/reboot.sh || echo "!!! Script execution failed"
            
            echo ">>> Finished executing $REBOOT_FILE commands"
          else
            echo ">>> No $REBOOT_FILE found, skipping custom commands"
          fi

          echo ">>> Configure & start OpenSSH server"
          sudo mkdir -p /var/run/sshd

          # 检查是否有保存的密码（从 ssh.txt 读取）
          SAVED_PASSWORD=""
          if [ -f ssh.txt ]; then
            SAVED_PASSWORD=$(grep -oP '(?<=password: ).+' ssh.txt 2>/dev/null || true)
            if [ -n "$SAVED_PASSWORD" ]; then
              echo ">>> Found saved password from ssh.txt, reusing it"
              ROOT_PASS="$SAVED_PASSWORD"
            fi
          fi
          
          # 如果没有保存的密码，生成新密码
          if [ -z "${ROOT_PASS:-}" ]; then
            ROOT_PASS="$(openssl rand -base64 18 | tr -d '=+/' | head -c 16)"
            echo ">>> Generated new root password (first run)"
          fi

          # 设置 root 密码
          echo "root:${ROOT_PASS}" | sudo chpasswd

          # 恢复 SSH host keys（如果存在）
          if [ -d key ]; then
            echo ">>> Found saved SSH host keys, restoring..."
            sudo cp -f key/* /etc/ssh/
            sudo chmod 600 /etc/ssh/ssh_host_*_key
            sudo chmod 644 /etc/ssh/ssh_host_*_key.pub
            echo ">>> SSH host keys restored"
          else
            echo ">>> No saved SSH host keys found, will generate new ones"
          fi

          # 调整 sshd 配置：允许 root & 密码登录
          sudo sed -i 's/^#\?PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config || true
          sudo sed -i 's/^#\?PasswordAuthentication .*/PasswordAuthentication yes/' /etc/ssh/sshd_config || true
          sudo sed -i 's/^#\?KbdInteractiveAuthentication .*/KbdInteractiveAuthentication no/' /etc/ssh/sshd_config || true

          # 启动 sshd（会自动生成缺失的 host keys）
          sudo /usr/sbin/sshd -D -e &
          SSHD_PID=$!
          echo ">>> sshd started with PID $SSHD_PID"
          
          # 等待 sshd 生成 host keys
          sleep 2
          
          # 备份 SSH host keys 到仓库（首次运行或 keys 更新时）
          if [ ! -d key ]; then
            echo ">>> Backing up SSH host keys..."
            mkdir -p key
            sudo cp /etc/ssh/ssh_host_*_key /etc/ssh/ssh_host_*_key.pub key/
            sudo chmod 644 key/*
            echo ">>> SSH host keys backed up to key/"
          fi

          # 只删除 ssh.txt，保留 web.txt（用户可能已自定义域名）
          rm -f ssh.txt

          # 提取仓库名称（去掉用户名前缀）
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          echo ">>> Repository name: $REPO_NAME"

          # ===== 管理 Serveo 客户端 SSH 密钥和指纹 =====
          SERVEO_KEY_FILE="key.txt"
          SERVEO_FINGERPRINT_FILE="fingerprint.txt"
          SERVEO_PRIVATE_KEY="$HOME/.ssh/serveo_client_key"
          
          # 确保 .ssh 目录存在
          mkdir -p "$HOME/.ssh"
          chmod 700 "$HOME/.ssh"
          
          if [ -f "$SERVEO_KEY_FILE" ]; then
            echo ">>> Found existing Serveo client key, restoring..."
            # 恢复私钥
            cat "$SERVEO_KEY_FILE" > "$SERVEO_PRIVATE_KEY"
            chmod 600 "$SERVEO_PRIVATE_KEY"
            
            # 恢复指纹
            if [ -f "$SERVEO_FINGERPRINT_FILE" ]; then
              SERVEO_FINGERPRINT=$(cat "$SERVEO_FINGERPRINT_FILE")
              echo ">>> Restored Serveo fingerprint: $SERVEO_FINGERPRINT"
            fi
          else
            echo ">>> Generating new Serveo client SSH key..."
            # 生成新的 ED25519 密钥（无密码）
            ssh-keygen -t ed25519 -f "$SERVEO_PRIVATE_KEY" -N "" -C "serveo-client-${REPO_NAME}"
            
            # 计算指纹
            SERVEO_FINGERPRINT=$(ssh-keygen -lf "$SERVEO_PRIVATE_KEY" | awk '{print $2}')
            echo ">>> Generated Serveo fingerprint: $SERVEO_FINGERPRINT"
            
            # 保存私钥和指纹到仓库
            cat "$SERVEO_PRIVATE_KEY" > "$SERVEO_KEY_FILE"
            echo "$SERVEO_FINGERPRINT" > "$SERVEO_FINGERPRINT_FILE"
            chmod 644 "$SERVEO_KEY_FILE" "$SERVEO_FINGERPRINT_FILE"
            
            echo ">>> Saved Serveo key and fingerprint to repository"
            
            # 首次生成密钥，需要提交到仓库
            git config user.name "permanent-node-automation"
            git config user.email "permanent-node-automation@noreply.local"
            git add "$SERVEO_KEY_FILE" "$SERVEO_FINGERPRINT_FILE" || true
            git commit -m "chore: add serveo client key and fingerprint" || true
            REMOTE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            git push "$REMOTE_URL" HEAD:${GITHUB_REF_NAME} || echo "git push failed (non-fatal)"
          fi

          # ===== 读取 web.txt 获取所有域名配置 =====
          declare -A PORT_DOMAINS
          PORT_DOMAINS_COUNT=0
          if [ -f "web.txt" ]; then
            echo ">>> Reading domain configuration from web.txt..."
            cat web.txt
            while IFS= read -r line; do
              [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
              if [[ "$line" =~ ^([0-9]+)[[:space:]]+https?://([^[:space:]]+) ]]; then
                port="${BASH_REMATCH[1]}"
                domain="${BASH_REMATCH[2]}"
                PORT_DOMAINS["$port"]="$domain"
                PORT_DOMAINS_COUNT=$((PORT_DOMAINS_COUNT + 1))
                echo ">>> Port $port -> domain: $domain"
              fi
            done < web.txt
          else
            echo ">>> web.txt not found, no domain configuration available"
          fi

          # ===== 配置 Cloudflare DNS TXT 记录（仅针对 mugassn.dpdns.org 子域）=====
          # 只为我们自己的子域配置 DNS，自定义域名由用户自己配置
          
          declare -A SUBDOMAINS_TO_CONFIGURE
          SUBDOMAIN_COUNT=0
          # 只在 PORT_DOMAINS 不为空时遍历
          if [ "$PORT_DOMAINS_COUNT" -gt 0 ]; then
            for port in "${!PORT_DOMAINS[@]}"; do
              domain="${PORT_DOMAINS[$port]}"
              # 检查是否为 mugassn.dpdns.org 子域（不包括 serveo.net）
              if [[ "$domain" =~ ^([^.]+)\.mugassn\.dpdns\.org$ ]]; then
                subdomain="${BASH_REMATCH[1]}"
                SUBDOMAINS_TO_CONFIGURE["$subdomain"]=1
                SUBDOMAIN_COUNT=$((SUBDOMAIN_COUNT + 1))
                echo ">>> Will configure DNS for subdomain: $subdomain"
              else
                echo ">>> Skipping DNS config for custom/external domain: $domain"
              fi
            done
          fi
          
          # 如果有需要配置的子域且有指纹，配置 DNS
          if [ "$SUBDOMAIN_COUNT" -gt 0 ] && [ -n "${SERVEO_FINGERPRINT:-}" ]; then
            echo ">>> Configuring Cloudflare DNS for $SUBDOMAIN_COUNT subdomains..."
            
            # Cloudflare API 配置
            CF_API_TOKEN="yHCjTnrTBDdlXq8FBdUho9gmolBVb1cRO-HUrNjs"
            CF_ZONE_ID="1381075946420150b48ef98ef234ca0b"
            CF_DOMAIN="mugassn.dpdns.org"
            
            # 为每个子域配置 DNS
            for subdomain in "${!SUBDOMAINS_TO_CONFIGURE[@]}"; do
              txt_record_name="_serveo-authkey.${subdomain}"
              full_domain="${txt_record_name}.${CF_DOMAIN}"
              
              echo ">>> Configuring DNS TXT record: ${full_domain}"
              
              # 检查记录是否已存在
              CHECK_URL="https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records?type=TXT&name=${full_domain}"
              CHECK_RESPONSE=$(curl -s -X GET "${CHECK_URL}" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json" || echo "")
              RECORD_ID=$(echo "$CHECK_RESPONSE" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "")
              
              if [ -n "$RECORD_ID" ]; then
                # 更新现有记录
                echo ">>> Updating existing DNS record (ID: $RECORD_ID)..."
                UPDATE_URL="https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records/${RECORD_ID}"
                RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X PUT "${UPDATE_URL}" \
                  -H "Authorization: Bearer ${CF_API_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "{\"type\":\"TXT\",\"name\":\"${txt_record_name}\",\"content\":\"\\\"${SERVEO_FINGERPRINT}\\\"\",\"ttl\":300,\"proxied\":false}" || echo "CURL_FAILED")
                echo ">>> Response: $RESPONSE"
              else
                # 创建新记录
                echo ">>> Creating new DNS record..."
                CREATE_URL="https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/dns_records"
                RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST "$CREATE_URL" \
                  -H "Authorization: Bearer ${CF_API_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "{\"type\":\"TXT\",\"name\":\"${txt_record_name}\",\"content\":\"\\\"${SERVEO_FINGERPRINT}\\\"\",\"ttl\":300,\"proxied\":false}" || echo "CURL_FAILED")
                echo ">>> Response: $RESPONSE"
              fi
              
              echo ">>> DNS configured for ${full_domain}"
            done
            
            # 等待 DNS 生效
            echo ">>> Waiting for DNS propagation (30 seconds)..."
            sleep 30
          else
            echo ">>> No subdomain DNS configuration needed"
          fi

          # 配置 SSH 客户端（禁用严格主机密钥检查）
          mkdir -p ~/.ssh
          {
            echo "Host serveo.net"
            echo "    StrictHostKeyChecking no"
            echo "    UserKnownHostsFile /dev/null"
            echo "    ServerAliveInterval 60"
            echo "    ServerAliveCountMax 3"
            echo "    IdentityFile $SERVEO_PRIVATE_KEY"
          } > ~/.ssh/config

          echo ">>> Start serveo tunnel for SSH (local port 22)"
          # SSH 隧道：ssh -J serveo.net root@mugassn-仓库名
          nohup ssh -i "$SERVEO_PRIVATE_KEY" -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R "mugassn-${REPO_NAME}:22:localhost:22" serveo.net > serveo_ssh.log 2>&1 &
          SSH_TUNNEL_PID=$!
          echo ">>> SSH tunnel started with PID $SSH_TUNNEL_PID"

          # 额外 TCP 端口（可为空：不填就是只开 SSH，不建任何端口映射）
          read -ra PORTS <<< "$PORT_LIST_STR"
          
          if [ "${#PORTS[@]}" -gt 0 ]; then
            echo ">>> Start serveo tunnels for extra TCP ports ..."
            for p in "${PORTS[@]}"; do
              p_trim="$(echo "$p" | xargs || true)"
              if [ -z "$p_trim" ]; then
                continue
              fi
              log_file="serveo_${p_trim}.log"
              
              # 使用 web.txt 中的域名配置（如果存在）
              if [ "$PORT_DOMAINS_COUNT" -gt 0 ] && [ -n "${PORT_DOMAINS[$p_trim]:-}" ]; then
                DOMAIN="${PORT_DOMAINS[$p_trim]}"
                echo "  - launching serveo tunnel for local port $p_trim with domain ${DOMAIN}..."
                nohup ssh -i "$SERVEO_PRIVATE_KEY" -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R "${DOMAIN}:80:localhost:${p_trim}" serveo.net > "$log_file" 2>&1 &
              else
                # 如果 web.txt 中没有配置，使用默认子域名
                SUBDOMAIN="mugassn-${REPO_NAME}"
                echo "  - launching serveo tunnel for local port $p_trim with default subdomain ${SUBDOMAIN}..."
                nohup ssh -i "$SERVEO_PRIVATE_KEY" -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -R "${SUBDOMAIN}:80:localhost:${p_trim}" serveo.net > "$log_file" 2>&1 &
              fi
            done
          fi

          echo ">>> Waiting for serveo to establish tunnels ..."
          sleep 10

          # 生成 SSH 连接命令
          SSH_CMD="ssh -J serveo.net root@mugassn-${REPO_NAME}"
          echo ">>> SSH command: ${SSH_CMD}"

          {
            echo "${SSH_CMD}"
            echo "password: ${ROOT_PASS}"
          } > ssh.txt

          # 如果 web.txt 不存在，生成它；如果已存在，保持不变
          if [ ! -f "web.txt" ] && [ "${#PORTS[@]}" -gt 0 ]; then
            echo ">>> Generating initial web.txt (fallback - should not happen normally)..."
            > web.txt
            for p in "${PORTS[@]}"; do
              p_trim="$(echo "$p" | xargs || true)"
              if [ -z "$p_trim" ]; then
                continue
              fi
              
              # 使用默认子域名格式：default-仓库名.mugassn.dpdns.org
              # 注意：这是备用方案，正常情况下 web.txt 应该由 index.php 创建
              SUBDOMAIN="default-${REPO_NAME}"
              echo "${p_trim} http://${SUBDOMAIN}.mugassn.dpdns.org" >> web.txt
            done
          else
            echo ">>> web.txt already exists, keeping existing configuration"
          fi
          
          # 添加 Serveo 指纹到 web.txt（如果还没有）
          if [ -n "${SERVEO_FINGERPRINT:-}" ]; then
            # 检查 web.txt 是否已包含指纹
            if ! grep -q "# Serveo SSH Key Fingerprint:" web.txt 2>/dev/null; then
              echo "" >> web.txt
              echo "# Serveo SSH Key Fingerprint:" >> web.txt
              echo "# ${SERVEO_FINGERPRINT}" >> web.txt
            fi
          fi

          echo ">>> Configure git & push ssh.txt / web.txt / key/ ..."
          git config user.name "permanent-node-automation"
          git config user.email "permanent-node-automation@noreply.local"

          git add ssh.txt web.txt key/ || true
          # 添加 Serveo 密钥和指纹文件
          [ -f key.txt ] && git add key.txt || echo "key.txt not found"
          [ -f fingerprint.txt ] && git add fingerprint.txt || echo "fingerprint.txt not found"
          # 添加 reboot.txt 和 shut.txt 到版本控制
          [ -f reboot.txt ] && git add reboot.txt || echo "reboot.txt not found"
          [ -f shut.txt ] && git add shut.txt || echo "shut.txt not found"
          [ -f backup.txt ] && git add backup.txt || echo "backup.txt not found (normal for first run)"
          TS="$(date -u +%Y%m%dT%H%M%SZ)"
          git commit -m "chore: update permanent node endpoints $TS" || echo "Nothing to commit"

          REMOTE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git push "$REMOTE_URL" HEAD:${GITHUB_REF_NAME} || echo "git push failed (non-fatal)"

          echo ">>> Permanent node ready! Local storage at /data"
          echo ">>> Running for ${TTL_MIN} minutes..."
          
          # 等待到 TTL 结束
          sleep "$TTL_SEC" || true
          echo ">>> TTL reached, executing shutdown commands if any..."
          
          # 执行关机前命令（如果存在）
          SHUTDOWN_FILE="shut.txt"
          if [ -f "$SHUTDOWN_FILE" ]; then
            echo ">>> Found $SHUTDOWN_FILE, executing shutdown commands..."
            echo ">>> Working directory: /root"
            
            # 转换 Windows 换行符为 Unix 格式
            sed -i 's/\r$//' "$SHUTDOWN_FILE" 2>/dev/null || true
            
            # 记录备份开始时间
            BACKUP_START=$(date +%s)
            echo ">>> Backup started at: $(date)"
            
            # 使用 sudo 切换到 /root 目录执行命令
            sudo bash -c "cd /root && while IFS= read -r cmd || [ -n \"\$cmd\" ]; do
              # 跳过空行和注释行
              if [ -z \"\$cmd\" ] || [[ \"\$cmd\" =~ ^[[:space:]]*# ]]; then
                continue
              fi
              
              echo \">>> Executing: \$cmd\"
              eval \"\$cmd\" || echo \"!!! Command failed: \$cmd\"
            done < \"$GITHUB_WORKSPACE/$SHUTDOWN_FILE\""
            
            # 计算备份用时
            BACKUP_END=$(date +%s)
            BACKUP_DURATION=$((BACKUP_END - BACKUP_START))
            echo ">>> Custom shutdown commands completed in ${BACKUP_DURATION} seconds"
            
            # 直接在工作流中执行备份上传
            echo ">>> Starting /data backup and upload..."
            if [ -d /data ] && [ "$(ls -A /data 2>/dev/null)" ]; then
              # 在临时目录创建备份，避免权限问题
              BACKUP_TIME=$(TZ='Asia/Shanghai' date +'%Y%m%d_%H%M%S')
              BACKUP_FILE="/tmp/data_backup_${BACKUP_TIME}.tar.gz"
              echo ">>> Creating backup: $BACKUP_FILE"
              tar -czf "$BACKUP_FILE" --exclude="$BACKUP_FILE" -C /data .
              
              # 检查文件大小
              BACKUP_SIZE=$(stat -c%s "$BACKUP_FILE" 2>/dev/null || echo "0")
              BACKUP_SIZE_MB=$((BACKUP_SIZE / 1024 / 1024))
              echo ">>> Backup size: ${BACKUP_SIZE_MB}MB"
              
              if [ "$BACKUP_SIZE_MB" -gt 1000 ]; then
                echo ">>> Backup is larger than 1000MB, splitting into 1000MB chunks..."
                # 切换到临时目录进行分片操作
                cd /tmp
                # 分割文件为1000MB的块
                split -b 1000M "$BACKUP_FILE" "${BACKUP_FILE}.part"
                rm -f "$BACKUP_FILE"  # 删除原始大文件
                
                # 重命名分片文件为part1, part2格式
                PART_NUM=1
                for part_file in "${BACKUP_FILE}".part*; do
                  if [ -f "$part_file" ]; then
                    NEW_NAME="data_backup_${BACKUP_TIME}.part${PART_NUM}.tar.gz"
                    mv "$part_file" "$NEW_NAME"
                    PART_NUM=$((PART_NUM + 1))
                  fi
                done
                
                # 上传所有分片
                UPLOAD_SUCCESS=true
                PART_COUNT=0
                for part_file in data_backup_${BACKUP_TIME}.part*.tar.gz; do
                  if [ -f "$part_file" ]; then
                    PART_COUNT=$((PART_COUNT + 1))
                    echo ">>> Uploading part ${PART_COUNT}: $(basename "$part_file")"
                    UPLOAD_RESULT=$(curl -s -F "files[]=@$part_file" https://pomf.lain.la/upload.php)
                    echo ">>> Upload result: $UPLOAD_RESULT"
                    DOWNLOAD_URL=$(echo "$UPLOAD_RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data['files'][0]['url'] if 'files' in data and len(data['files']) > 0 else '')" 2>/dev/null || echo "")
                    
                    if [ -n "$DOWNLOAD_URL" ]; then
                      echo ">>> Part ${PART_COUNT} upload successful: $DOWNLOAD_URL"
                      echo "$(basename "$part_file") $DOWNLOAD_URL" >> "$GITHUB_WORKSPACE/backup.txt"
                    else
                      echo "!!! Part ${PART_COUNT} upload failed"
                      UPLOAD_SUCCESS=false
                    fi
                    rm -f "$part_file"
                  fi
                done
                
                if [ "$UPLOAD_SUCCESS" = true ]; then
                  echo ">>> All ${PART_COUNT} parts uploaded successfully"
                else
                  echo "!!! Some parts failed to upload"
                fi
              else
                echo ">>> Backup size is acceptable, uploading as single file..."
                echo ">>> Uploading to pomf..."
                cd /tmp
                UPLOAD_RESULT=$(curl -s -F "files[]=@$BACKUP_FILE" https://pomf.lain.la/upload.php)
                echo ">>> Upload result: $UPLOAD_RESULT"
                DOWNLOAD_URL=$(echo "$UPLOAD_RESULT" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data['files'][0]['url'] if 'files' in data and len(data['files']) > 0 else '')" 2>/dev/null || echo "")
                if [ -n "$DOWNLOAD_URL" ]; then
                  echo ">>> Upload successful: $DOWNLOAD_URL"
                  echo "$(basename "$BACKUP_FILE") $DOWNLOAD_URL" >> "$GITHUB_WORKSPACE/backup.txt"
                else
                  echo "!!! Upload failed or could not parse response"
                fi
                rm -f "$BACKUP_FILE"
              fi
            else
              echo ">>> No /data directory found or empty, skipping backup"
            fi
          else
            echo ">>> No $SHUTDOWN_FILE found, skipping shutdown commands"
          fi
          
          # 提交 backup.txt 到仓库（无论是否执行了关机命令）
          cd "$GITHUB_WORKSPACE"
          if [ -f backup.txt ]; then
            echo ">>> Committing backup.txt to repository..."
            git add backup.txt || true
            # 确保其他重要文件也被添加
            git add ssh.txt web.txt key/ reboot.txt shut.txt || true
            [ -f key.txt ] && git add key.txt || true
            [ -f fingerprint.txt ] && git add fingerprint.txt || true
            [ -f port_domain_config.json ] && git add port_domain_config.json || true
            BACKUP_TS="$(date -u +%Y%m%dT%H%M%SZ)"
            git commit -m "chore: update backup links and node info $BACKUP_TS" || true
            REMOTE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            git push "$REMOTE_URL" HEAD:${GITHUB_REF_NAME} || true
            echo ">>> backup.txt and other files committed successfully"
          fi
          
          # 等待备份完全完成
          echo ">>> Waiting for backup sync to complete..."
          sleep 30
          
          echo ">>> Triggering next run to replace this one..."
          
          # 触发新运行（会自动取消当前运行）
          curl -s -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/dispatches" \
            -d '{"event_type":"restart-permanent-node"}' || echo "Trigger failed, cron will handle restart"
          
          echo ">>> New run triggered, current run will be cancelled automatically"
          echo ">>> Waiting for cancellation..."
          
          # 给下一轮启动缓冲时间，避免重叠
          sleep 180  # 3分钟缓冲时间
